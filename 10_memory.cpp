#define _CRT_SECURE_NO_WARNINGS 1   
#include <iostream>
#include <string>
using namespace std;
/*
* 内存的分区模型
* 1.代码区：存放函数体的二进制代码，由操作系统进行管理
* 2.全局区：存放全局变量和静态变量以及常量
* 3.栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
* 4.堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
* 
* 不同存放区域的数据，赋予不同的生命周期，给我们更大灵活的变成
* 
*/

/*
* 程序运行前，在程序编译后，生成了exe可执行程序，未执行程序分为2个区域
* 
* 1.代码区
* 存放cpu执行的机器指令
* 代码区共享，目的对于频繁执行的程序，只需要在内存中有一份代码即可
* 代码区是只读的，防止程序意外修改了他的指令
* 
* 2.全局区
* 全局变量和静态变量
* 常量区、字符串常量和其他常量
* 该区域在程序运行结束后由操作系统释放
*	函数体内的变量都叫局部变量
*	在普通变量前加static，属于是静态变量
* 常量;
* 字符串常量
* const修改的全局变量和局部变量
* 任何局部变量都不在全局区
*/



/*
* 程序运行后
* 
* 栈区：函数的参数值，以及局部变量等
* 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
*
* 堆区：由程序员分配，程序结束后由操作系统释放
* C++中利用new在堆区开辟内存
*/

//栈区的注意事项
int* func()
{
	int a = 10;  //局部变量存放在栈区，函数执行完成后自动释放
	return &a;    //返回局部变量的地址 
}
int * func1()
{
	//利用new关键字可以将数据开辟到堆区
	int *p = new int(20);//返回地址编号
	return p;
	//delete 释放堆区
}

int main10()
{
	int* p = func();
	cout << *p << endl;  //第一次可以打印正确的数字是因为编译器做了保留
	cout << *p << endl;  //第二次编译器不在保留

	
	//在堆区开辟数据
	//指针本质也是局部变量，放在栈上，指针保存的数据放在堆区

	int* p1 = func1();
	cout << *p1 << endl;
	cout << *p1 << endl;


	
	return 0;
}